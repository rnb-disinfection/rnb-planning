/** 
 * Example on how to use the MotionModel class
 */
#include <expressiongraph/motionmodel.hpp>
#include <fstream>
#include <boost/timer.hpp>

using namespace KDL;

int main() {
    using namespace Eigen;
    using namespace std;
    using namespace KDL;
    // to test the above class:
   
    int nrofjoints = 3; 
    MotionModel model(CubicSpline::NATURAL,nrofjoints);

    // file generated by matlab script, should be in the directory where you execute this program.
    int retval=model.readModel("motionmodel.csv"," ,", 0);  
    if (retval!=0) {        
        cerr << "could not read model, errorcode : "<< retval << endl;
        return -retval;
    }
    cout << model << endl;
    double v        = 1.0;
    double s0       = 0.0;
    double duration = 1.0;
    double sample_time = 1E-3;
    VectorXd  x_star(model.getNrOfModes());
    x_star << 1.0, 0.0;
    VectorXd  h(nrofjoints);
    MatrixXd  H(nrofjoints,model.getNrOfModes()+2); 
    {
        ofstream outp("result1.csv");
        for (double t=0;t<duration; t+=sample_time) {
            model.setInputValues(t,v,s0, x_star);
            model.value(h);
            model.jacobian(H);
            outp << t << " ," <<  h(0) << " ," << h(1) << " ," << h(2) << "\n";
        }
        outp.close();
    }

    // some other tests:
    {
        // it is indeed a function of v and s0:
        x_star << 1.0, 0.0;
        v = 2.0;
        s0 = 0.2;
        duration = 0.4;
        ofstream outp("result2.csv");
        for (double t=0;t<duration; t+=sample_time) {
            model.setInputValues(t,v,s0, x_star);
            model.value(h);
            model.jacobian(H);
            outp << t << " ," <<  h(0) << " ," << h(1) << " ," << h(2) << "\n";
        }
        outp.close();
    }
    {
        // testing the other mode
        x_star << 0.0, 1.0;
        v = 1.0;
        s0 = 0.0;
        duration = 1.0;
        ofstream outp("result3.csv");
        for (double t=0;t<duration; t+=sample_time) {
            model.setInputValues(t,v,s0, x_star);
            model.value(h);
            model.jacobian(H);
            outp << t << " ," <<  h(0) << " ," << h(1) << " ," << h(2) << "\n";
        }
        outp.close();
    }
/*    
 *    uncomment if you want to run this:
 */
 {
        // testing the timing:
        cout << "testing the timing for 1 000 000  evaluations" << endl;
        cout << "(without output to file)" << endl;
        boost::timer t1;
        x_star << 1.0, 0.0;
        v = 1.0;
        s0 = 0.0;
        duration = 1.0;
        sample_time = 1E-6;
        for (double t=0;t<duration; t+=sample_time) {
            model.setInputValues(t,v,s0, x_star);
            model.value(h);
            model.jacobian(H);
        }
        cout << "elapsed time "<< t1.elapsed() << "sec. per time step : " << t1.elapsed()*sample_time*1000000.0 << " microsec for value + Jacobian" <<endl;
        sample_time = 1E-3;
    }
/**/
    {
        // comparing to numerical derivative:
        // Jacobian:
        x_star << 1.0, 0.5;
        v = 2.0;
        s0 = 0.2;
        duration = 0.4;
        double t = 0.3;
        double delta = 1E-12;
        VectorXd h1  (model.getNrOfJoints());
        VectorXd h2  (model.getNrOfJoints());
        MatrixXd Hnum(model.getNrOfJoints(), model.getNrOfModes()+2);
        // evaluate the Jacobian via expressiongraphs:
        model.setInputValues(t,v,s0, x_star);
        model.value(h);
        model.jacobian(H);

        // numberical towards v
        model.setInputValues( t,v+delta,s0,x_star);
        model.value(h1);
        model.setInputValues( t,v-delta,s0,x_star);
        model.value(h2);
        Hnum.col(0) = (h1-h2)/2.0/delta;
        // numberical towards s0
        model.setInputValues( t,v,s0+delta,x_star);
        model.value(h1);
        model.setInputValues( t,v,s0-delta,x_star);
        model.value(h2);
        Hnum.col(1) = (h1-h2)/2.0/delta;
        // numerical towards x_star(0)
        double tmp = x_star(0);
        x_star(0) = tmp + delta;
        model.setInputValues( t,v,s0,x_star);
        model.value(h1);
        x_star(0) = tmp - delta;
        model.setInputValues( t,v,s0,x_star);
        model.value(h2);
        x_star(0) = tmp;
        Hnum.col(2) = (h1-h2)/2.0/delta;
        // numerical towards x_star(1)
        tmp = x_star(1);
        x_star(1) = tmp + delta;
        model.setInputValues( t,v,s0,x_star);
        model.value(h1);
        x_star(1) = tmp - delta;
        model.setInputValues( t,v,s0,x_star);
        model.value(h2);
        x_star(1) = tmp;
        Hnum.col(3) = (h1-h2)/2.0/delta;


        cout << "H via expressiongraphs \n" << H << endl;
        cout << "H via num. diff        \n" << Hnum << endl;
    }

    { 
        // just for the curious....
        // output a graphical representation of the expressiongraphs:
             /** from documentation files:
             * start a dotfile 
             *
             * Use it as follows:
             *  - write_dotfile_start(of)
             *  - e1->write_dotfile_init()
             *  - e2->write_dotfile_init()
             *  - e1->write_dotfile_update(of)
             *  - e2->write_dotfile_update(of)
             *  - write_dotfile_end(of)
             *
             * You can use e->write_dotfile(of) if you only have to write one expression to the dot-file.
             *
             * \param [in] of stream to output to. 
             * with the xdot and dot tool (graphviz package) you can visualize the expressiongraph
             **/
        ofstream of("motionmodel.dot"); 
        write_dotfile_start(of);
        model.outputs[0]->write_dotfile_init();
        model.outputs[1]->write_dotfile_init();
        model.outputs[2]->write_dotfile_init();
        model.outputs[0]->write_dotfile_update(of);
        model.outputs[1]->write_dotfile_update(of);
        model.outputs[2]->write_dotfile_update(of);
        write_dotfile_end(of);
        of.close();
    }    


    return 0;
}


